# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xsEcYAWRdouVkk-xdUuVZ43PdKe2Nk4S
"""

import math

def int_to_posit16(n: int, es: int) -> str:
    if es not in (0, 1, 2):
        raise ValueError("es must be 0, 1, or 2")

    if n == 0:
        return "0" * 16

    neg = n < 0
    n = abs(n)

    useed = 2 ** (2 ** es)

    # --- regime k ---
    k = int(math.floor(math.log(n, useed)))

    # --- regime bits ---
    if k >= 0:
        regime = "1" * (k + 1) + "0"
    else:
        regime = "0" * (-k) + "1"

    # --- scaled value ---
    scaled = n / (useed ** k)

    # --- exponent ---
    exp = 0
    if es > 0:
        exp = int(math.floor(math.log2(scaled)))
        exp = max(0, min(exp, (1 << es) - 1))
        scaled /= (2 ** exp)

    exp_bits = format(exp, f"0{es}b")

    used = 1 + len(regime) + es
    if used >= 16:
        final = 0x7FFF
    else:
        frac = scaled - 1
        frac_bits = ""
        for _ in range(16 - used + 1):  # guard bit
            frac *= 2
            if frac >= 1:
                frac_bits += "1"
                frac -= 1
            else:
                frac_bits += "0"

        raw = "0" + regime + exp_bits + frac_bits
        final = int(raw[:16], 2)

        # round-to-nearest
        if len(raw) > 16 and raw[16] == "1":
            final += 1

        final = min(final, 0x7FFF)

    if neg:
        final = (~final + 1) & 0xFFFF

    return format(final, "016b")

# print(int_to_posit16(5.5, 1))

import math

def int_to_posit16_0(n: int) -> str:
    """
    Convert integer to posit(16,0) binary string.
    Simple truncation rounding (matches tochinet-style behavior).
    """

    if n == 0:
        return "0" * 16

    neg = n < 0
    n = abs(n)

    # --- regime k (power of 2) ---
    k = int(math.floor(math.log2(n)))

    # --- regime bits ---
    # k >= 0 always for integer >= 1
    regime = "1" * (k + 1) + "0"

    # --- check overflow ---
    if 1 + len(regime) >= 16:
        posit = "0" + "1" * 14 + "1"  # 0111111111111111
    else:
        # --- scaled value ---
        scaled = n / (2 ** k)  # in [1, 2)

        # --- fraction ---
        frac = scaled - 1
        frac_bits = ""
        remaining = 16 - (1 + len(regime))

        for _ in range(remaining):
            frac *= 2
            if frac >= 1:
                frac_bits += "1"
                frac -= 1
            else:
                frac_bits += "0"

        posit = "0" + regime + frac_bits
        posit = posit[:16].ljust(16, "0")

    # --- twoâ€™s complement for negatives ---
    if neg:
        val = int(posit, 2)
        val = (~val + 1) & 0xFFFF
        posit = format(val, "016b")

    return posit
# print(int_to_posit16_0(-5))

def posit16_to_float(p: str, es: int) -> float:
    """
    Convert posit(16, es) binary string to decimal float.
    Supports es = 0, 1, 2.
    """

    if es not in (0, 1, 2):
        raise ValueError("es must be 0, 1, or 2")

    if len(p) != 16 or any(c not in "01" for c in p):
        raise ValueError("Input must be a 16-bit binary string")

    # Zero
    if p == "0" * 16:
        return 0.0

    # --- sign / two's complement ---
    neg = p[0] == "1"
    if neg:
        val = int(p, 2)
        val = (~val + 1) & 0xFFFF
        p = format(val, "016b")

    useed = 2 ** (2 ** es)

    # --- regime ---
    i = 1
    regime_bit = p[i]
    run = 0

    while i < 16 and p[i] == regime_bit:
        run += 1
        i += 1

    if regime_bit == "1":
        k = run - 1
    else:
        k = -run

    # skip terminating bit
    i += 1

    # --- exponent ---
    exp = 0
    if es > 0 and i + es <= 16:
        exp = int(p[i:i+es], 2)
        i += es

    # --- fraction ---
    frac = 0.0
    scale = 0.5
    while i < 16:
        if p[i] == "1":
            frac += scale
        scale /= 2
        i += 1

    value = (useed ** k) * (2 ** exp) * (1 + frac)

    return -value if neg else value

# print(posit16_to_float("0111111011010110", 0))

def decode_posit16(p: int, es: int):
    # 1. Handle Special Cases
    if p == 0:
        return 0, 0, 0        # Zero
    if p == 0x8000:
        return None, None, None # NaR (Not a Real) / Infinity

    # 2. Decode Sign & 2's Complement
    neg = (p & 0x8000) != 0
    if neg:
        p = (~p + 1) & 0xFFFF
        # Note: In Python, 0x8000 would cause issues here if not handled above,
        # but we already returned None for it.

    # 3. Decode Regime
    i = 14
    rb = (p >> i) & 1
    run = 0

    # Iterate while bits match the regime bit (rb)
    while i >= 0 and ((p >> i) & 1) == rb:
        run += 1
        i -= 1

    k = run - 1 if rb else -run

    # 4. Skip Terminator (CRITICAL FIX)
    # The loop ended because we hit a different bit (terminator) or ran out of bits.
    # If we haven't run out of bits, we must skip the terminator.
    if i >= 0:
        i -= 1

    # 5. Decode Exponent
    exp = 0
    if es > 0:
        # Check if we actually have enough bits left for the exponent
        if i >= 0:
            # We want 'es' bits, but we might have fewer than 'es' remaining
            # if the number is very small/large.
            shift = max(0, i - es + 1)
            bits_to_read = min(es, i + 1) # Read whatever fits

            # Extract and align
            exp = (p >> shift) & ((1 << bits_to_read) - 1)

            # If we were forced to read fewer bits (run out of space),
            # the standard says we treat missing LSBs as 0.
            # The shift above naturally aligns MSBs correctly if we are careful.
            # Actually, standard posit shifts exponent into place from the LEFT.
            # If we only have 1 bit of exponent '1', and es=2, exp should be 2 (binary 10), not 1.
            if bits_to_read < es:
                 exp <<= (es - bits_to_read)

            i -= es
        else:
            # No bits left for exponent, implies exp=0
            exp = 0

    scale = k * (1 << es) + exp

    # 6. Decode Mantissa
    # Whatever is left is fraction
    frac_len = max(0, i + 1)
    frac = 0
    if frac_len > 0:
        frac = p & ((1 << frac_len) - 1)

    # Normalize to Q1.16 (1.xxxxxxxxxxxxxxxx)
    # We shift the fraction to the left to fill the 16 slots
    mantissa = (1 << 16) | (frac << (16 - frac_len))

    return (-1 if neg else 1), scale, mantissa

def encode_posit16(sign, scale, mantissa, es):
    if mantissa == 0:
        return 0

    # normalize mantissa
    while mantissa >= (1 << 15):
        mantissa >>= 1
        scale += 1

    while mantissa < (1 << 14):
        mantissa <<= 1
        scale -= 1

    k = scale >> es
    exp = scale & ((1 << es) - 1)

    # regime
    if k >= 0:
        regime_bits = ('1' * (k + 1)) + '0'
    else:
        regime_bits = ('0' * (-k)) + '1'

    exp_bits = format(exp, f'0{es}b') if es > 0 else ''
    frac_bits = format(mantissa & ((1 << 14) - 1), '014b')

    posit_bits = regime_bits + exp_bits + frac_bits
    posit_bits = posit_bits[:15].ljust(15, '0')

    posit = int(posit_bits, 2)

    if sign < 0:
        posit = (~posit + 1) & 0xFFFF

    return posit

def align(m, shift):
    if shift <= 0:
        return m
    if shift >= 16:
        return 1  # sticky only
    sticky = 1 if (m & ((1 << shift) - 1)) else 0
    return (m >> shift) | sticky

def posit16_add(pa: int, pb: int, es: int) -> int:
    sa, ka, ma = decode_posit16(pa, es)
    sb, kb, mb = decode_posit16(pb, es)

    # align scales
    if ka > kb:
        mb = align(mb, ka - kb)
        k = ka
    else:
        ma = align(ma, kb - ka)
        k = kb

    # add mantissas
    m = sa * ma + sb * mb
    if m == 0:
        return 0

    sign = -1 if m < 0 else 1
    m = abs(m)

    # ðŸ”¥ normalization for Q1.16
    if m >= (1 << 17):   # overflow (>= 2.0)
        m >>= 1
        k += 1

    return encode_posit16(sign, k, m >> 2, es)
    # >>2 drops guard bits back to Q1.14 for encoder

def posit_add(a: int, b: int, es: int):
    # --- int â†’ posit (BITSTRING) ---
    if es == 0:
        pa_str = int_to_posit16_0(a)
        pb_str = int_to_posit16_0(b)
    else:
        pa_str = int_to_posit16(a, es)
        pb_str = int_to_posit16(b, es)

    # --- convert bitstring â†’ integer for hardware ---
    pa = int(pa_str, 2)
    pb = int(pb_str, 2)

    # --- posit-domain hardware add ---
    ps = posit16_add(pa, pb, es)

    # --- convert result back to bitstring ---
    ps_str = format(ps, "016b")

    # --- decode for display ---
    value = posit16_to_float(ps_str, es)

    return {
        "a_posit": pa_str,
        "b_posit": pb_str,
        "sum_posit": ps_str,
        "sum_decimal": value,
        "sum_integer": int(value)
    }


def posit16_mul(pa: int, pb: int, es: int) -> int:
    sa, ka, ma = decode_posit16(pa, es)
    sb, kb, mb = decode_posit16(pb, es)

    # --- special cases ---
    if sa is None or sb is None:
        return 0x8000
    if ma == 0 or mb == 0:
        return 0

    sign = sa * sb
    k = ka + kb

    # Q1.16 Ã— Q1.16 â†’ Q2.32
    prod = ma * mb

    # ---- shift back to Q1.16 (CRITICAL FIX) ----
    m = prod >> 16
    rem = prod & ((1 << 16) - 1)

    # ---- guard + sticky ----
    guard = (rem >> 15) & 1
    sticky = 1 if (rem & ((1 << 15) - 1)) else 0

    # ---- normalization ----
    if m >= (1 << 17):   # â‰¥ 2.0
        m >>= 1
        k += 1

    while m < (1 << 16): # < 1.0
        m <<= 1
        k -= 1

    # ---- round to nearest even ----
    lsb = m & 1
    if guard and (sticky or lsb):
        m += 1
        if m >= (1 << 17):
            m >>= 1
            k += 1

    # encoder expects Q1.14
    return encode_posit16(sign, k, m >> 2, es)



def posit_mul(a: float, b: float, es: int):
    # --- int â†’ posit (BITSTRING) ---
    if es == 0:
        pa_str = int_to_posit16_0(a)
        pb_str = int_to_posit16_0(b)
    else:
        pa_str = int_to_posit16(a, es)
        pb_str = int_to_posit16(b, es)

    # --- bitstring â†’ integer ---
    pa = int(pa_str, 2)
    pb = int(pb_str, 2)

    # --- posit-domain multiply ---
    pp = posit16_mul(pa, pb, es)

    # --- back to bitstring ---
    pp_str = format(pp, "016b")

    # --- decode for display ---
    value = posit16_to_float(pp_str, es)

    return {
        "a_posit": pa_str,
        "b_posit": pb_str,
        "prod_posit": pp_str,
        "prod_decimal": value
    }

def mul(num1: float, num2: float, es: int = 1) -> float:
    # --- decimal â†’ posit bitstring ---
    if es == 0:
        p1_str = int_to_posit16_0(num1)
        p2_str = int_to_posit16_0(num2)
    else:
        p1_str = int_to_posit16(num1, es)
        p2_str = int_to_posit16(num2, es)

    # --- bitstring â†’ integer (hardware form) ---
    p1 = int(p1_str, 2)
    p2 = int(p2_str, 2)

    # --- posit-domain multiply ---
    p_prod = posit16_mul(p1, p2, es)

    # --- back to decimal ---
    return posit16_to_float(format(p_prod, "016b"), es)

def add(num1: float, num2: float, es: int = 1) -> float:
    # --- decimal â†’ posit bitstring ---
    if es == 0:
        p1_str = int_to_posit16_0(num1)
        p2_str = int_to_posit16_0(num2)
    else:
        p1_str = int_to_posit16(num1, es)
        p2_str = int_to_posit16(num2, es)

    # --- bitstring â†’ integer (hardware form) ---
    p1 = int(p1_str, 2)
    p2 = int(p2_str, 2)

    # --- posit-domain add ---
    p_sum = posit16_add(p1, p2, es)

    # --- back to decimal ---
    return posit16_to_float(format(p_sum, "016b"), es)



